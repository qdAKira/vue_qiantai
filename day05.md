复习：
1）完成商品分类的三级列表路由跳转一级路由传参（合并参数）
2)完成search模块中对于typeNav使用（过渡动画的）
3）对于typeNav请求次数进行优化
1:swiper在Vue项目中使用 （开发ListContainer组件【首页banner图片】） 提示：卸载插件，你可以不用删除node_modules文件夹，可以使用npm uninstall xxxx进行卸载 
  1.1swiper安装到项目当中

  1.2在相应的组件引入swiper.js|swiper.css

  但是需要注意，home模块很多组件都使用到swiper.css,没必要在每一个组件内部都引入样式一次， 只需要在入口文件引入一次即可。

  1.3:初始化swiper实例在哪里书写? 初始化swiper实例之前，页面中的节点（结构）务必要有， 对于Vue一个组件而言，mounted[组件挂载完毕：相应的结构不就有了吗] mounted-->组件挂载完毕

  1.4动态效果为什么没有出来？ Swiper需要获取到轮播图的节点DOM，才能给swiper轮播添加动态效果， 因为没有获取到节点。

  1.5第一种解决方案，延迟器（不是完美的解决方案） 同学的想法：都不是完美的【错误的想法】 created里面：created执行与mounted执行，时间差可能2ms，白扯   updated里面：如果组件有很多响应式（data），只要有一个属性值发生变化updated还会再次执行，再次初始化实例。

  总结：第一种解决方案可以通过延迟器（异步）去解决问题， 但是这种解决方案存在风险（无法确定用户请求到底需要多长时间），因此没办法确定 延迟器时间。

2:Swiper在Vue项目中使用完美解决方案 第一种解决方案问题出现在哪里：v-for,在遍历来自于Vuex（数据:通过ajax向服务器发请求，存在异步）

  watch:监听属性，watch可以检测到属性值的变化，当属性值发生变化的时候，可以出发一次。

  Vuex当中的仓库数据bannerList（组件在使用）： bannerList仓库数据有没有发生过变化？ 一定是有的：bannerList初始值空数组，当服务器的数据返回以后，它的bannerList存储的属性值会发生变化【变为服务器返回的数据】 组件实例在使用仓库中的bannerList，组件的这个属性bannerList一定是发生过变化，watch可以监听到。

  组件实例的一个方法:nextTickthis.nextTick(()=>{

  }) nextTick官网解释: 在下次DOM更新, 循环结束之后,执行延迟回调。在 修改数据之后 立即使用这个方法，获取更新后的DOM。 注意：组件实例的$nextTick方法，在工作当中经常使用，经常结合第三方插件使用，获取更新后的DOM节点

  总结: 1:Swiper插件工作的是很常用（今晚把API、基本使用方法）看看 2:组件实例的$nextTick方法。 在下次DOM更新, 循环结束之后,执行延迟回调。在 修改数据之后 立即使用这个方法，获取更新后的DOM

2）开发floor组件
  切记：仓库中的state的数据格式，取决于服务器返回的数据，不要瞎写
 2.1：getFloorList这个action在哪里触发，是需要在Home路由组件当中发的，不能在Floor组件内部发action,因为我们需要v-for遍历floor组件

 2.2v-for也可以在自定义标签当中使用

 2.3组件通信的方式有哪些？面试频率较高
  1.props:用于父子组件通信
  2.自定义事件：@on,@emit 可以实现子给父通信
  3.全局事件总线：$bus 全能
  4.pubsub-js:vue当中几乎不用 全能
  5.插槽（3种） 
  6.vuex

3)把首页当中轮播图拆分为一个共用全局组件
  切记：以后在开发项目的时候，如果看到某一组件在很多地方都使用，将它变为全局组件，注册一次，可以在任意地方使用，共用的组件|非路由组件放到components文件夹中

4）search模块开发
  1.先写静态页面+静态组件，拆分出来
  2.发请求（api）
  3.vuex（三连环处理数据）
  4.组件获取仓库数据，动态展示数据
  
